import java.util.*;

public class MultiDimensionalKnapsackSolver {

    private final int POPULATION_SIZE;
    private final int NUM_OF_GENERATIONS;
    private final double MUTATION_RATE;
    private final double CROSS_OVER_RATE;
    private final List<Item> items;
    private final List<Item> profitBasedSortedItems;
    private final List<Knapsack> knapsacks;
    private final List<Individual> population;
    private final List<Integer> parentIndices;
    private final Map<Integer, Integer> defaultIndexToSortedIndex;
    private final Map<Integer, Integer> sortedIndexToDefaultIndex;

    public MultiDimensionalKnapsackSolver(int POPULATION_SIZE, int NUM_OF_GENERATIONS, double MUTATION_RATE,
                                          double CROSS_OVER_RATE, List<Item> items, List<Knapsack> knapsacks) {
        this.POPULATION_SIZE = POPULATION_SIZE;
        this.NUM_OF_GENERATIONS = NUM_OF_GENERATIONS;
        this.MUTATION_RATE = MUTATION_RATE;
        this.CROSS_OVER_RATE = CROSS_OVER_RATE;
        this.items = items;
        this.knapsacks = knapsacks;
        this.population = new ArrayList<>();

        this.parentIndices = new ArrayList<>();
        for (int i = 0; i < POPULATION_SIZE; i++) {
            parentIndices.add(i);
        }

        this.profitBasedSortedItems = new ArrayList<>();
        profitBasedSortedItems.addAll(items);
        Collections.sort(profitBasedSortedItems);

        defaultIndexToSortedIndex = new HashMap<>();
        for (int i = 0; i < items.size(); i++) {
            defaultIndexToSortedIndex.put(i, profitBasedSortedItems.indexOf(items.get(i)));
        }

        sortedIndexToDefaultIndex = new HashMap<>();
        for (int i = 0; i < items.size(); i++) {
            sortedIndexToDefaultIndex.put(i, items.indexOf(profitBasedSortedItems.get(i)));
        }
    }
    // A random genome sequence is generated by appending '0' or '1' to the new genome string.
    // If the new added bit (item) causes an infeasibility then that item is not added thus the bit at that index is set to '0'.
    // This is applied to generate an initial population with only feasible solutions (individuals).
    private Individual randomGenome(int size) {
        Random rand = new Random();
        Individual ind;
        StringBuilder genome = new StringBuilder();

        genome.append("0".repeat(items.size()));
        for (int i = 0; i < size; i++) {
            if (rand.nextBoolean()) {
                genome.setCharAt(i, '1');
                if (!isFeasible(genome.toString(), true))
                    genome.setCharAt(i, '0');
            }
        }
        ind = new Individual(genome.toString(), evaluateFitness(items, genome.toString()));
        return ind;
    }
    // This method evaluates the fitness of the genome given in the parameter by summing all the selected items' values,
    // if the genome sequence is feasible, if not then fitness is set to 0
    private int evaluateFitness(List<Item> items, String genome) {
        int fitness = 0;
        if (!isFeasible(genome, true))
            return 0;
        for (int i = 0; i < items.size(); i++) {
            fitness = (genome.charAt(i) == '1') ? (fitness + items.get(i).getValue()) : fitness;
        }
        return fitness;
    }
    // The method checks whether the given genome sequence yields a feasible solution for the problem.
    // Here, flag parameter determines which item list order will be considered to match the genome sequence with the items;
    // item order given in the input and profit base sorted item list which is used in repair function.
    private boolean isFeasible(String genome, boolean flag) {
        List<Item> items;
        if (flag)
            items = this.items;
        else
            items = this.profitBasedSortedItems;

        int totalConstraintSum;
        for (int i = 0; i < knapsacks.size(); i++) {
            totalConstraintSum = 0;
            for (int j = 0; j < items.size(); j++) {
                if (genome.charAt(j) == '1')
                    totalConstraintSum += items.get(j).getConstraints().get(i);
            }
            if (totalConstraintSum > knapsacks.get(i).getCapacity())
                return false;
        }
        return true;
    }
    //4 random individuals are selected from the population as parent nominees.
    // These 4 Individuals are paired to have a “tournament” in
    //which the one with the highest fitness wins. 2 individuals from the tournament (i.e. winners),
    //are passed to the next stage.
    private List<Individual> selectParents(List<Individual> population) {

        Collections.shuffle(parentIndices);
        List<Individual> parents = new ArrayList<>();
        //First Pair Winner Selection
        if (population.get(parentIndices.get(0)).getFitness() > population.get(parentIndices.get(1)).getFitness())
            parents.add(population.get(parentIndices.get(0)));
        else
            parents.add(population.get(parentIndices.get(1)));
        //Second Pair Winner Selection
        if (population.get(parentIndices.get(2)).getFitness() > population.get(parentIndices.get(3)).getFitness())
            parents.add(population.get(parentIndices.get(2)));
        else
            parents.add(population.get(parentIndices.get(3)));
        return parents;
    }
    //Here we have 2 Individuals named as male and
    //female. The male and female Individual’s genomes are divided into parts with the portion of
    //CROSS_OVER_RATE and then these portions are switched to generate a mixed child.
    private List<Individual> crossOver(Individual male, Individual female) {
        List<Individual> children = new ArrayList<>();
        //Setting the point of separation of the genomes
        int midPointIndex =
                female.getGenome().length() - (int) Math.floor(female.getGenome().length() * CROSS_OVER_RATE);
        // Male genome is split into parts
        String maleFirstPart = male.getGenome().substring(0, midPointIndex);
        String maleLastPart = male.getGenome().substring(midPointIndex);
        // Female genome is split into parts
        String femaleFirstPart = female.getGenome().substring(0, midPointIndex);
        String femaleLastPart = female.getGenome().substring(midPointIndex);
        // Parents are mixed by switching their parts
        String firstChild = maleFirstPart + femaleLastPart;
        String secondChild = femaleFirstPart + maleLastPart;
        children.add(new Individual(firstChild, evaluateFitness(items, firstChild)));
        children.add(new Individual(secondChild, evaluateFitness(items, secondChild)));

        return children;
    }

    //The genome is traversed, and at each iteration of the traversal,
    //a random number is generated by the program and if this random number is below the
    //MUTATION_RATE constant, then a mutation occurs and the bit at the current index is
    //flipped.
    private Individual mutate(Individual individual) {
        Random rand = new Random();
        // Trave
        for (int i = 0; i < individual.getGenome().length(); i++) {
            if (rand.nextDouble() < MUTATION_RATE) {
                String genome = individual.getGenome();
                String mutatedGenome;
                if (genome.charAt(i) == '1')
                    mutatedGenome = genome.substring(0, i) + '0' + genome.substring(i + 1);
                else
                    mutatedGenome = genome.substring(0, i) + '1' + genome.substring(i + 1);
                individual.setGenome(mutatedGenome);
                //The new genome's fitness value is evaluated
                individual.setFitness(evaluateFitness(items, mutatedGenome));
            }
        }
        return individual;
    }


    private void generateNewPopulation(List<Individual> population) {

        // Sort the population with respect to their fitness
        Collections.sort(population);

        // Obtain 2 parents
        List<Individual> parents = selectParents(population);

        // Apply crossover to the parents and obtain 2 new individuals
        List<Individual> children = crossOver(parents.get(0), parents.get(1));

        // Apply mutation to the children obtained after the crossOver operation
        Individual mutatedChild1 = mutate(children.get(0));
        Individual mutatedChild2 = mutate(children.get(1));

        // If the mutated genome is not feasible, apply repair method
        if (!isFeasible(mutatedChild1.getGenome(), true))
            repair(mutatedChild1);

        if (!isFeasible(mutatedChild2.getGenome(), true))
            repair(mutatedChild2);

        // 2 individuals in the population having the lowest fitness are replaced with the 2 children
        // obtained by these operations.
        children.set(0, mutatedChild1);
        children.set(1, mutatedChild2);

        // Check whether the children are unique, if so, insert them to the beginning of the population
        boolean isFirstChildUnique = true;
        boolean isSecondChildUnique = true;

        for (int i = 0; i < POPULATION_SIZE; i++) {
            if (!isFirstChildUnique && !isSecondChildUnique)
                break;
            if (population.get(i).getGenome().equals(children.get(0).getGenome()))
                isFirstChildUnique = false;
            if (population.get(i).getGenome().equals(children.get(1).getGenome()))
                isSecondChildUnique = false;
        }
        if (isFirstChildUnique)
            population.set(0, children.get(0));
        if (isSecondChildUnique)
            population.set(1, (children.get(1)));
    }

    public Individual getBestSolution() {
        return population.get(population.size() - 1);
    }


    private void repair(Individual infeasible) {

        // Initialize new genome
        StringBuilder newGenome = new StringBuilder();
        newGenome.append("0".repeat(items.size()));

        // Reorder the indices from default to sorted
        for (int i = 0; i < infeasible.getGenome().length(); i++) {
            if (infeasible.getGenome().charAt(i) == '1')
                newGenome.setCharAt(defaultIndexToSortedIndex.get(i), '1');
        }

        // Traverse the genome from the beginning, replacing ‘1’ with ‘0’ until a feasible solution is found
        for (int i = 0; i < newGenome.length(); i++) {
            if (newGenome.charAt(i) == '1') {
                newGenome.setCharAt(i, '0');
                if (isFeasible(newGenome.toString(), false))
                    break;
            }
        }

        // Traverse the genome from the end, replacing ‘0’ with ‘1’ if it does not violate any constraint
        for (int i = newGenome.length() - 1; i >= 0; i--) {
            if (newGenome.charAt(i) == '0') {
                newGenome.setCharAt(i, '1');
                if (!isFeasible(newGenome.toString(), false))
                    newGenome.setCharAt(i, '0');
            }
        }

        StringBuilder finalGenome = new StringBuilder();
        finalGenome.append("0".repeat(items.size()));

        // Reorder the indices from sorted to default
        for (int i = 0; i < infeasible.getGenome().length(); i++) {
            if (newGenome.charAt(i) == '1')
                finalGenome.setCharAt(sortedIndexToDefaultIndex.get(i), '1');
        }
        infeasible.setFitness(evaluateFitness(items, finalGenome.toString()));
        infeasible.setGenome(finalGenome.toString());
    }

    public void run() {

        // Generate initial population
        for (int i = 0; i < POPULATION_SIZE; i++) {
            population.add(randomGenome(items.size()));
        }

        // Run until the number of generations is reached
        for (int i = 1; i <= NUM_OF_GENERATIONS; i++) {
            generateNewPopulation(population);
            System.out.println("Current value = " + population.get(population.size() - 1).getFitness() + " " +
                    "\t\tGENERATION = " + i);
        }
    }
}
